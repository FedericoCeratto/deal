# More about testing

This section assumes that you're familiar with [basic testing](../basic/tests.md) and describes how you can get more from deal testing mechanisms.

## Finding memory leaks

Sometimes, when a function is completed, it leaves in memory other objects except result. For example:

```python
cache = {}
User = dict

def get_user(name: str) -> User:
    if name not in cache:
        cache[name] = User(name=name)
    return cache[name]
```

Here, `get_user` creates a `User` object and stores it in a global cache. In this case, this "leak" is a desired behavior and we don't want to fight it. This is why we can't a tool (or something right in the Python interpreter) that catches and reports such behavior, it would have too many false-positives.

However, things are different with pure functions. A pure function can't store anything on a side because it is a side effect. The result of a pure function is only what it returns.

The command `memtest` uses this idea to find memory leaks in pure functions. How it works:

1. It finds all pure functions (as `test` does).
1. For every function:
    1. It makes memory snapshot before running the function.
    1. It runs the function with different autogenerated input arguments (as `test` command does) without running contracts and checking the return value type (to avoid side-effects from deal itself).
    1. It makes memory snapshot after running the function.
    1. Snapshots "before" and "after" are comapared. If there is a difference it will be printed.

The return code is equal to the amount of functions with memory leaks.

If the function fails, the command will ignore it and still test the function for leaks. Side-effects shouldn't happen unconditionally, even if the function fails. If you want to find unexpected failures, use `test` command instead.
